trigger:
- main

variables:
  # Azure Resources
  azureSubscription: '8ce37efe-06df-47c4-b146-001d3ddfb1ba'
  resourceGroup: 'Project-Freshers_Park_Resource'
  containerRegistry: 'Project-Freshers-Park-App.azurecr.io'
  containerAppName: 'django-app'
  containerAppEnv: 'Project-Freshers-Park-App'
  composeFilePath: '**/docker-compose.yml'
  AZURE_KEY_VAULT_NAME: 'Freshers-Park-Keys'
  
  # Application Settings (non-secrets)
  DJANGO_SETTINGS_MODULE: 'job_portal.settings.production'
  DB_HOST: 'postgres'
  DB_PORT: '5432'
  DEBUG: 'False'
  ALLOWED_HOSTS: 'project-freshers-park-app-ezfqg6ezhyhvbzbx.centralindia-01.azurewebsites.net'
  PGADMIN_DEFAULT_EMAIL: 'admin@fresherspark.in'

stages:
- stage: Build
  displayName: Build and push images
  jobs:
  - job: Build
    displayName: Build
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      displayName: 'Configure Key Vault Access'
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Get the service principal ID for the current Azure DevOps connection
          spId=$(az ad sp show --id $(servicePrincipalId) --query id -o tsv)
          
          if [ -z "$spId" ]; then
            echo "##vso[task.logissue type=error]Failed to get service principal ID"
            exit 1
          fi

          echo "Service Principal ID: $spId"
          
          # Grant Key Vault access
          az keyvault set-policy \
            --name $(AZURE_KEY_VAULT_NAME) \
            --resource-group $(resourceGroup) \
            --object-id $spId \
            --secret-permissions get list \
            --output table

          # Verify access was granted
          echo "Current Key Vault access policies:"
          az keyvault show \
            --name $(AZURE_KEY_VAULT_NAME) \
            --query "properties.accessPolicies[?objectId == '$spId']" \
            --output table

    - task: AzureKeyVault@1
      displayName: 'Get secrets from Key Vault'
      inputs:
        azureSubscription: $(azureSubscription)
        KeyVaultName: $(AZURE_KEY_VAULT_NAME)
        SecretsFilter: '*'
        RunAsPreJob: true

    - bash: |
        echo "##vso[task.setvariable variable=DB_NAME]$(DB-NAME)"
        echo "##vso[task.setvariable variable=DB_USER]$(DB-USER)"
        echo "##vso[task.setvariable variable=DB_PASSWORD]$(DB-PASSWORD)"
        echo "##vso[task.setvariable variable=SECRET_KEY]$(SECRET-KEY)"
        echo "##vso[task.setvariable variable=EMAIL_HOST_PASSWORD]$(EMAIL-HOST-PASSWORD)"
        echo "##vso[task.setvariable variable=PGADMIN_DEFAULT_PASSWORD]$(PGADMIN-DEFAULT-PASSWORD)"
      displayName: 'Map Key Vault Secrets to Pipeline Variables'

    - task: DockerCompose@0
      displayName: 'Build services'
      inputs:
        containerregistrytype: 'Azure Container Registry'
        azureSubscription: $(azureSubscription)
        azureContainerRegistry: $(containerRegistry)
        dockerComposeFile: $(composeFilePath)
        action: 'Build services'
        additionalImageTags: '$(Build.BuildId)'
        dockerComposeFileArgs: |
          DB_NAME=$(DB_NAME)
          DB_USER=$(DB_USER)
          DB_PASSWORD=$(DB_PASSWORD)
          SECRET_KEY=$(SECRET_KEY)
          EMAIL_HOST_PASSWORD=$(EMAIL_HOST_PASSWORD)
          PGADMIN_DEFAULT_PASSWORD=$(PGADMIN_DEFAULT_PASSWORD)

    - task: DockerCompose@0
      displayName: 'Push services'
      inputs:
        containerregistrytype: 'Azure Container Registry'
        azureSubscription: $(azureSubscription)
        azureContainerRegistry: $(containerRegistry)
        dockerComposeFile: $(composeFilePath)
        action: 'Push services'
        additionalImageTags: '$(Build.BuildId)'

- stage: Deploy
  displayName: Deploy to Azure Container Apps
  dependsOn: Build
  jobs:
  - job: Deploy
    displayName: Deploy
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      displayName: 'Install Container Apps Extension'
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az extension add --name containerapp --upgrade
          az provider register --namespace Microsoft.App

    - task: AzureCLI@2
      displayName: 'Deploy Container App'
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Login to ACR
          az acr login --name $(containerRegistry)
          
          # Get the latest image tag
          WEB_IMAGE=$(az acr repository show-tags \
            --name $(containerRegistry) \
            --repository $(containerAppName) \
            --orderby time_desc \
            --query [0] -o tsv)
          
          # Create or update container app
          az containerapp update \
            --name $(containerAppName) \
            --resource-group $(resourceGroup) \
            --environment $(containerAppEnv) \
            --image $(containerRegistry)/$(containerAppName):$WEB_IMAGE \
            --target-port 8000 \
            --ingress external \
            --env-vars \
              DJANGO_SETTINGS_MODULE=$(DJANGO_SETTINGS_MODULE) \
              DB_HOST=$(DB_HOST) \
              DB_PORT=$(DB_PORT) \
              DB_NAME=$(DB_NAME) \
              DB_USER=$(DB_USER) \
              DEBUG=$(DEBUG) \
              ALLOWED_HOSTS=$(ALLOWED_HOSTS) \
              PGADMIN_DEFAULT_EMAIL=$(PGADMIN_DEFAULT_EMAIL) \
            --secrets \
              db-password=$(DB_PASSWORD) \
              secret-key=$(SECRET_KEY) \
              email-password=$(EMAIL_HOST_PASSWORD) \
              pgadmin-password=$(PGADMIN_DEFAULT_PASSWORD)

          # Show deployment status
          echo "##[section]Deployment Details:"
          az containerapp show \
            --name $(containerAppName) \
            --resource-group $(resourceGroup) \
            --query "{FQDN:configuration.ingress.fqdn, ProvisioningState:provisioningState, Revision:latestRevisionName}" \
            --output table